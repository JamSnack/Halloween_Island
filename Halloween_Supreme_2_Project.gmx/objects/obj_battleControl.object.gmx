<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///INITIALIZE VARAIBLES - BATTLE SPECIFICATIONS HANDLED WITH scr_startBattle();
//FOR TASKA: The instantiation of this object begins a battle. Simply execute scr_startBattle();
//and pass in the proper parameters to begin the fight.

location = "GRASS"; //Current location for use in determining background and music.
background = noone; //Container for future background reference
battle_music = noone; //Music to use for the battle.

//ENEMY VARIABLES
enemy_id = noone; //List of enemy IDs. Noone if DNE. NOTE: Currently only 1 enemy ID is expected.
enemy_sprite = spr_battle_monster;
enemy_idle_offset = 8;
enemy_idle_wave = random(360); //Interpolates between 0 and 360.
reverse_idle = 0; //1 or 0. Determines whether or not to reverse the idle animation. See the approach line in step event. (ln. 2)
enemy_name = noone;
enemy_level = noone;
enemy_hp = noone;
enemy_max_hp = noone;
image_zForce = 0; //The z and y force control how much force to apply to rotating the sprite in 3D space.
image_yForce = 1; //Needs to be 1 when passed to image_yscale;
hurt_flash = 0;
death_explosion = false; //Whether or not the enemy death explosion has gone off.

//GAME CONTROL VARIABLES
player_turn = true; //True = player turn, false = enemy turn.
chosen_action = noone; //Noone if no action is chosen; otherwise the name of the action.
battle_timer = 0; //A timer useful for keeping track of things during the battle.
action_selected = 0; //Keeps track of the action selected. 0=attack, 1=item, 2=run
item_action_selected = 0; //Keeps track of the attack action selected.
attack_action_selected = 0; //Keeps track of the item action selected.
action_finalized = noone; //Keeps track of the selected action_selected. Noone if not in use.
battle_string = ""; //The text that is show during battle.
attack_string = ""; //The text that lists the player's attack in battle.
item_string = "";
battle_string_max_length = 190; //The maximum length of the battle string.
battle_string_max_height = 40; //The maximum height of the battle stirng.
battle_exit = false; //Whether or not to run the battle exit sequence.
possible_attacks = ds_list_create(); //Container for attacks to be available during battle. Destroyed in user_event0
possible_items = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//------------Gather input-------------
var key_select = (keyboard_check_released(vk_enter) || keyboard_check_released(ord('Z')));
var key_left = (keyboard_check_released(vk_left) || keyboard_check_released(ord("A")));
var key_right = (keyboard_check_released(vk_right) || keyboard_check_released(ord("D")));
var key_cancel = (keyboard_check_released(ord('X')));
var key_up = (keyboard_check_released(vk_up) || keyboard_check_released(ord("W")));
var key_down = (keyboard_check_released(vk_down) || keyboard_check_released(ord("S")));

//-----------Animate the enemy---------
if battle_exit == false
{
    enemy_idle_wave = approach(enemy_idle_wave,360-(360*reverse_idle),0.025);
    
    if enemy_idle_wave &gt;= 360
    {
        reverse_idle = 1;
        enemy_idle_wave = 360;
    }
    else if enemy_idle_wave &lt;= 0
    {
        reverse_idle = 0;
        enemy_idle_wave = 0;
    }

// - z and y force approach 0 and 1 respectively.
    if image_zForce != 0 { image_zForce = approach(image_zForce, 0, image_zForce/10 ); }
    if image_yForce != 1 { image_yForce = approach(image_yForce, 1, image_yForce/10 ); }
}

//- hurt_flash
if hurt_flash &gt; 0
{
    hurt_flash -= 0.1;
    
    if hurt_flash &lt; 0 then hurt_flash = 0;
}

//- rotation
image_angle += image_zForce;
image_yscale = sin(image_yForce);

//Make corrections after animation is completed.

if image_yscale != 1 &amp;&amp; image_yForce &lt;= 1.1
{
    image_yscale = approach(image_yscale,1, 0.1);
}

if image_angle != 0 &amp;&amp; image_zForce &lt;= 0.1
{
    var _img = round(image_angle) mod 360;
    var _targ = 0;
    
    image_angle = _img; //Prepare image_angle for rotation correction.
    
    //Set the approach target to the point that it is closest to.
    if _img &gt; 180 then _targ = 360;
    
    //Approach the target
    image_angle = approach(image_angle, _targ, ceil(image_angle/10));
    
    //Reset image_angle to avoid strange, unknown cases
    if image_angle == _targ then image_angle = 0;
}

//----------Game Brain!----------------
// game brain gaming gameing gamer
if player_turn == true &amp;&amp; battle_exit == false
{
 /*   if chosen_action != noone
    {
        //Execute the chosen action
        scr_executeAttack(chosen_action);
        chosen_action = noone;
        player_turn = false;
        battle_timer = 0;
    }    
    */
    //If an option is not selected, allow control of the action_selected pointer.
    if action_finalized == noone
    {
        //Move the action_selected pointer
        if key_left &amp;&amp; action_selected &gt; 0
        {
            action_selected -= 1;
        }
        else if key_right &amp;&amp; action_selected &lt; 2
        {
            action_selected += 1;
        }
        
        //Make a selection
        
        if key_select
        {
            action_finalized = action_selected;
        }
    }
    else
    {
        //Perhaps we may want to cancel an action.
        if key_cancel
        {
            attack_string = "";
            item_string = "";
            action_finalized = noone;
        }
        
        //Further the selection
        switch action_selected
        {
            case 0: //Attack options
            {
                //An array that holds the player's possible attacks.
                //Move the selection pointer
                if key_up &amp;&amp; attack_action_selected &gt; 0
                {
                    attack_action_selected -= 1;
                }
                else if key_down &amp;&amp; attack_action_selected &lt; 1 //NOTE: Replace with number of options in the future
                {
                    attack_action_selected += 1;
                }
                
                //Construct the attack string and list the possible attacks
                if attack_string == ""
                {
                    for(str_index=0;str_index&lt;array_length_1d(global.unlocked_attacks);str_index++)
                    {
                        var _attack = global.unlocked_attacks[str_index];
                        
                        if _attack == 1
                        {
                            var _data = scr_getAttackInfo(str_index);
                            attack_string += (_data[0]+"#");
                            
                            //add to our list of possible attacks
                            ds_list_add(possible_attacks,str_index);
                        }
                    }
                }
                
                //Select an option and execute that attack!
                if key_select
                {
                    scr_executeAttack(possible_attacks[| attack_action_selected]);
                }
            }
            break;
            
            case 1: //Item options
            {
                if key_up &amp;&amp; item_action_selected &gt; 0
                {
                    item_action_selected -= 1;
                }
                else if key_down &amp;&amp; item_action_selected &lt; 1 //NOTE: Replace with number of options in the future
                {
                    item_action_selected += 1;
                }

                //Construct the item string and list the possible items
                if item_string == ""
                {
                    for(str_index=0;str_index&lt;array_length_1d(global.battle_items);str_index++)
                    {
                        var _item = global.battle_items[str_index];
                        
                        if _item == 1 &amp;&amp; global.inventory[| str_index] &gt; 0
                        {
                            var _name = scr_getItemInfo(str_index);
                            item_string += (_name+" x"+string(scr_inven_find_item(str_index))+"#");
                            
                            //add to our list of possible items
                            ds_list_add(possible_items,str_index);
                        }
                    }
                }
                
                //Select an option and execute that attack!
                if key_select
                {
                    scr_executeItem(possible_items[| item_action_selected]);
                }
            }
            break;
            
            case 2: //Run option
            {
                if (irandom(100) &gt;= enemy_level/global.player_stats[STATS.level])
                {
                    battle_timer = 0;
                    battle_exit = true;
                    battle_string = "";
                    action_finalized = noone;
                    battle_string += "You fled successfully!#"
                }
                else if (battle_exit == false)
                {
                    battle_string += "The "+enemy_name+" prevents your flee.#";
                    player_turn = false;
                }
            }
            break;
        }
    }
}
else if battle_exit == false
{
    if battle_timer &gt; room_speed*2
    {
        //The enemy executes an attack!
        global.player_stats[STATS.hp] -= enemy_level;
        battle_string += ("You take "+string(enemy_level)+" damage.#");
        player_turn = true;
        action_finalized = noone;
        scr_playSound(snd_player_hurt,false,3,0,0,1,true);
        //Note: Screenshake will not work with draw GUI atm!
    }
}

//---Increment timer----
battle_timer += 1;

//-----format battle text------
if string_width(battle_string) &gt; battle_string_max_length
{
    battle_string = scr_fitText(battle_string,battle_string_max_length);
}

if string_height(battle_string) &gt; battle_string_max_height
{
    //We should remove text. Let's delete the first-most message.
    var new_str = "";
    
    for(_i=1;_i&lt;string_length(battle_string);_i++)
    {
        var char = string_char_at(battle_string,_i);
        new_str += char;
        
        if char == "#" 
            { show_debug_message(new_str); break; }
    }
    
    battle_string = string_delete(battle_string,1,string_length(new_str));
}


//-----FORMAT TEXT------
//Note: using battle_string_max_length and other variables are fine here. Same textbox :P
if string_width(attack_string) &gt; battle_string_max_length
{
    attack_string = scr_fitText(attack_string,battle_string_max_length);
}

if string_height(attack_string) &gt; battle_string_max_height
{
    //We should remove text. Let's delete the first-most message.
    var new_str = "";
    
    for(_i=1;_i&lt;string_length(attack_string);_i++)
    {
        var char = string_char_at(attack_string,_i);
        new_str += char;
        
        if char == "#" 
            { show_debug_message(new_str); break; }
    }
    
    attack_string = string_delete(attack_string,1,string_length(new_str));
}


if string_width(attack_string) &gt; battle_string_max_length
{
    attack_string = scr_fitText(attack_string,battle_string_max_length);
}

if string_height(item_string) &gt; battle_string_max_height
{
    //We should remove text. Let's delete the first-most message.
    var new_str = "";
    
    for(_i=1;_i&lt;string_length(item_string);_i++)
    {
        var char = string_char_at(item_string,_i);
        new_str += char;
        
        if char == "#" 
            { show_debug_message(new_str); break; }
    }
    
    item_string = string_delete(item_string,1,string_length(new_str));
}

//-------Battle Exit Sequence------------
if battle_exit == true 
{
    //Exit the fight
    if battle_timer &gt; 4*room_speed
    {
        instance_destroy();
    }
    
    //Death animation
    //- fade to alpha 0 after a second
    if battle_timer &gt; 1*room_speed &amp;&amp; image_alpha &gt; 0
    {
        image_alpha -= 0.01;
    }
    
    //- spawn annoying particles?
    
    //- gently spin
    image_zForce = 2;
    image_yForce += 0.1;
    
    //- ascend
    enemy_idle_wave = approach(enemy_idle_wave,-360,0.01);
}


//---------MANAGE SOUNDS------------
if key_left || key_right || key_select || key_up || key_down || key_cancel
{
    scr_playSound(snd_generic_selection,false,2,0,0,1,false);
}

//-------DEATH ANIMATION PARTICLES----
if image_alpha == 0 &amp;&amp; battle_exit == true &amp;&amp; death_explosion == false
{
    //These variables are used to allign the explosion with the Draw GUI event's draw_sprite_ext(spr_enemy) function   
    var wind_width = 256*1.27;
    var wind_height = 224*1.5;
    var wind_center_x = wind_width/2;
    var wind_center_y = wind_height/2;
    var _enemy_offset = enemy_idle_offset*sin(enemy_idle_wave);
    
    //BAD
    //instance_create(wind_center_x-40,wind_center_y-64+_enemy_offset,efct_death_explosion);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///END THE BATTLE
//NOTE: Replace reward values with more intelligent functions later.
var reward_exp = enemy_level*10;
var reward_gold = enemy_level*100;

//Enemy defeated?
if enemy_hp &lt;= 0
{
    enemy_hp = 0;
    battle_string = "";
    battle_string += (enemy_name+" deafeted!#+"+string(reward_exp)+" EXP! +"+string(reward_gold)+" Candy!");
}

//Battle exit stuff
battle_exit = true;
battle_timer = 0;
action_finalized = noone;
ds_list_destroy(possible_attacks);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the battle
var wind_width = 256;
var wind_height = 224;
var wind_center_x = wind_width/2;
var wind_center_y = wind_height/2;

draw_set_font(global.fnt_outlined);

//Draw the background
draw_background(background,0,0);

//Draw the enemy
if image_alpha &gt; 0
{
    var _enemy_offset = enemy_idle_offset*sin(enemy_idle_wave);
    
    //Draw name and level
    draw_set_halign(fa_center);
    draw_text(wind_center_x,wind_center_y-64+_enemy_offset,enemy_name+" Lv. "+string(enemy_level)+"##HP: "+string(enemy_hp)+"/"+string(enemy_max_hp));
    draw_set_halign(fa_left);
    
    //Draw shadow
    draw_sprite_ext(spr_battle_shadow,0,wind_center_x,wind_center_y+32,0.5+_enemy_offset/50,0.5+_enemy_offset/50,0,c_white,image_alpha+_enemy_offset/10);
    
    //Draw body
    shader_set(shd_flash); 
    draw_sprite_ext(spr_battle_monster,enemy_id,wind_center_x,wind_center_y+_enemy_offset,1,image_yscale,image_angle,c_white,1);
    shader_reset();
    draw_sprite_ext(spr_battle_monster,enemy_id,wind_center_x,wind_center_y+_enemy_offset,1,image_yscale,image_angle,image_blend,image_alpha-hurt_flash);
}

//- hp and mp
var hp_str = ("HP: "+string(global.player_stats[STATS.hp])+"");
var mp_str = ("MP: "+string(global.player_stats[STATS.mp])+"");

draw_text(wind_width-10-string_width(hp_str),wind_height-60,hp_str);
draw_text(wind_width-10-string_width(mp_str),wind_height-50,mp_str);


//Draw info textbox
draw_set_colour(c_black);
draw_rectangle(0,wind_height-40,wind_width,wind_height,false);
draw_set_colour(c_white);
draw_set_font(global.fnt_normal);

//Draw action options
if player_turn == true
{
    //Attack
    if action_finalized == noone || action_finalized == 0
        { draw_sprite(spr_battle_option,0,3,wind_height-41-16); }
    //Item
    if action_finalized == noone || action_finalized == 1
        { draw_sprite(spr_battle_option,1,3+34,wind_height-41-16); }
    //Run
    if action_finalized == noone || action_finalized == 2
        { draw_sprite(spr_battle_option,2,3+68,wind_height-41-16); }
    
    //Draw selection pointers
    if action_finalized == noone
    {
        draw_sprite(spr_ui_battle_option_selector,0,3+16+(34*action_selected),wind_height-41-16-4);
    }
    else if action_finalized == 0
    {
        draw_sprite(spr_ui_battle_option_selector,1,4,wind_height-34+(7*attack_action_selected))
    }
    else if action_finalized == 1
    {
        draw_sprite(spr_ui_battle_option_selector,1,4,wind_height-34+(7*item_action_selected))
    }
    
}

//Draw info
switch action_finalized
{
    case 0:
    {
        draw_text(5,wind_height-38,attack_string);
    }
    break;
    
    case 1:
    {
        draw_text(5,wind_height-38,item_string);
    }
    break;
    
    //Covers case noone and case 2 (RUN)
    default: draw_text(5,wind_height-38,battle_string);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///TEMPORARY: APPLY RANDOM FORCE
/*
image_zForce = irandom(360);
image_yForce = irandom(360);

show_debug_message("zForce: "+string(image_zForce)+" | yForce"+string(image_yForce));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
