<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Note that a cell is valid only if it lies within the bounds of the maze, 
AND it has not previously been visited: we only want to carve passages into 
untouched cells, to avoid creating circular loops in the maze.
*/


/*
    DESCRIBING THE PROCESSS:
1. First we want to fill up the room with tiles.
2. We want to carve a maze in those tiles using a Recursive Backtracing algorithm.
*/

randomize();

//Grid height and width are 0 indexed. This 10x10 maze's last column is 9.
maze_size = 24;
tile_size = 32;
path_length = 2;
maze_grid = ds_grid_create(maze_size,maze_size);

//Set each cell in the grid to 1 to denote that something is there.
for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        ds_grid_set(maze_grid,i,f,1);
    }
}

//Initialize the carve - Must start at an odd point and move by 2.
carver_x = 1;
carver_y = 1;
check_next = true; //Whether or not to check the next direction.
backstep = false; //Whether or not to enable to backstepping routine.
directions_checked = ds_list_create(); //A list containing the checked directions of the carver during generation.
visited_cells_x = ds_list_create();
visited_cells_y = ds_list_create();
maze_complete = false;

directions_x = ds_map_create();
ds_map_add(directions_x,"N",0);
ds_map_add(directions_x,"S",0);
ds_map_add(directions_x,"E",1);
ds_map_add(directions_x,"W",-1);

directions_y = ds_map_create();
ds_map_add(directions_y,"N",-1);
ds_map_add(directions_y,"S",1);
ds_map_add(directions_y,"E",0);
ds_map_add(directions_y,"W",0);

ds_list_add(visited_cells_x,carver_x);
ds_list_add(visited_cells_y,carver_y);

ds_grid_set(maze_grid,carver_x,carver_y,0);

time = 0;
time_framerate = 10;

view_xview -= 32;
view_yview -= 32;

//Zoom out over the maze!
//Initial zoom
var zoom = 0.1;

view_wview = ((maze_size)*8)/zoom;
view_hview = ((maze_size)*8)/zoom;;

camera.x = floor(maze_size/2)*tile_size;
camera.y = floor(maze_size/2)*tile_size;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CARVE THE LABYRINTH!
//if (time mod time_framerate == 0) then exit;

//NOTE: When checking for grid coordinates, an invalid coordinate will also return 0.

if maze_complete == false
{
    //Select a random direction
    var move_to = choose("N","S","W","E");
    
    //Pick a new direction if the current direction is in the list.
    if ds_list_find_index(directions_checked,move_to) != -1
    {
        //If all directions checked, backstep. Otherwise find a new direction.
        if ds_list_size(directions_checked) &gt;= 4
        {
            ds_list_clear(directions_checked);
            
            if ds_list_size(visited_cells_x) &gt; 0
            {
                show_debug_message("MAZE GEN&gt; Entering backstep routine..");
                backstep = true;
                backstep_position = ds_list_size(visited_cells_x)-1;
            }
        }
        else
        {
            while(ds_list_find_index(directions_checked,move_to) != -1)
            {
                move_to = choose("N","S","W","E");
            }
        }
    }
    
    ds_list_add(directions_checked,move_to);
    
    var next_x = carver_x+directions_x[? move_to]*path_length;
    var next_y = carver_y+directions_y[? move_to]*path_length;
    
    if move_to != undefined &amp;&amp; next_x &gt; 0 &amp;&amp; next_y &gt; 0 &amp;&amp; next_x &lt; maze_size-1 &amp;&amp; next_y &lt; maze_size-1 &amp;&amp; ds_grid_get(maze_grid,next_x,next_y) != 0
    {
        maze_grid_update(move_to,path_length);
        backstep = false;
        scr_playSound(snd_generic_selection,false,2,0,0,0.5,true);
    }
    
    //BACKSTEP
    if (backstep == true &amp;&amp; ds_list_size(visited_cells_x) &gt; 0)
    {
        ds_list_delete(visited_cells_x,backstep_position);
        ds_list_delete(visited_cells_y,backstep_position);
        backstep_position -= 1;
        carver_x = ds_list_find_value(visited_cells_x,backstep_position);
        carver_y = ds_list_find_value(visited_cells_y,backstep_position);
    
        if backstep_position &lt;= 0
        {
            backstep = false;
            maze_complete = true;
            event_user(0); //MAZE COMPLETED EVENT
            show_debug_message("BACKSTEP REACHED 0. MAZE COMPLETE.");
        }
    }
}
else
{    
    //Zoom into the maze
    var zoom = 1;
    var zoom_speed = 3;
    //- set zoom targets
    var x_zoom = 256/zoom;
    var y_zoom = 256/zoom;
    
    if (view_wview != x_zoom) || (view_hview != y_zoom)
    {
        view_wview = approach(view_wview,x_zoom,(zoom_speed*view_wview/x_zoom)*zoom_speed);
        view_hview = approach(view_hview,y_zoom,(zoom_speed*view_hview/y_zoom)*zoom_speed);
    }
    else
    {
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_yview -= 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_yview += 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview += 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview -= 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///MAZE COMPLETED EVENT
//Here we want to take our maze and make it playable!

//Punch middle hole
hole_size = 3; //A 3x3 hole.
starting_x = floor(maze_size/2);
starting_y = floor(maze_size/2);

//Punch a hole to place the character
for(_i=0;_i&lt;hole_size*hole_size;_i++)
{
    var column = floor(_i/hole_size);
    ds_grid_set(maze_grid,starting_x+_i-(column*hole_size),starting_y+column,0);   
}

//Convert to objects
for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        if ds_grid_get(maze_grid,f,i) == 1
        {
            instance_create(10+tile_size*f,10+tile_size*i,obj_wall);
        }
        else if ds_grid_get(maze_grid,f,i) == 0 
        { 
            instance_create(10+tile_size*f,10+tile_size*i,obj_road);
        }
    }
}


//Create player
instance_create(starting_x*tile_size+tile_size*2,starting_y*tile_size+tile_size,obj_player);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the generation process
var xx = 10;
var yy = 10;


for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        if ds_grid_get(maze_grid,f,i) == 1
        {
            draw_sprite(spr_tile_small,0,xx+f*tile_size,yy+i*tile_size);
        }
    }
}

draw_sprite(spr_tile_small,1,xx+carver_x*tile_size,yy+carver_y*tile_size);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
