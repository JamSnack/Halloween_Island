<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Note that a cell is valid only if it lies within the bounds of the maze, 
AND it has not previously been visited: we only want to carve passages into 
untouched cells, to avoid creating circular loops in the maze.
*/


/*
    DESCRIBING THE PROCESSS:
1. First we want to fill up the room with tiles.
2. We want to carve a maze in those tiles using a Recursive Backtracing algorithm.
*/

randomize();

//RULES: maze_size must be an odd number.
maze_size = min(9+maze_difficulty*2,75);
tile_size = 32;
path_length = 2;
maze_grid = ds_grid_create(maze_size,maze_size);

//Set each cell in the grid to 1 to denote that something is there.
for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        ds_grid_set(maze_grid,i,f,1);
    }
}

//Initialize the carve - Must start at an odd point and move by 2.
carver_x = 1;
carver_y = 1;
check_next = true; //Whether or not to check the next direction.
backstep = false; //Whether or not to enable to backstepping routine.
directions_checked = ds_list_create(); //A list containing the checked directions of the carver during generation.
visited_cells_x = ds_list_create();
visited_cells_y = ds_list_create();
maze_complete = false; //Whether or not the wall carving step has been completed.
maze_conditions_passed = false; //Whether or not the maze generated correctly as to satisfy specific conditions.

directions_x = ds_map_create();
ds_map_add(directions_x,"N",0);
ds_map_add(directions_x,"S",0);
ds_map_add(directions_x,"E",1);
ds_map_add(directions_x,"W",-1);

directions_y = ds_map_create();
ds_map_add(directions_y,"N",-1);
ds_map_add(directions_y,"S",1);
ds_map_add(directions_y,"E",0);
ds_map_add(directions_y,"W",0);

ds_list_add(visited_cells_x,carver_x);
ds_list_add(visited_cells_y,carver_y);

ds_grid_set(maze_grid,carver_x,carver_y,0);

time = 0;
time_framerate = 10;

view_xview -= 32;
view_yview -= 32;

//Zoom out over the maze!
//Initial zoom
camera.zoom = 0.2;
//camera.x_zoom = ((maze_size)*8)/zoom;
//camera.y_zoom = ((maze_size)*8)/zoom;
//camera.x = floor(maze_size/2)*tile_size;
//camera.y = floor(maze_size/2)*tile_size;
camera.follow_this = 'MAZE';
camera.zoom_speed = 8;

//Music
if audio_is_playing(snd_The_Maw_of_the_Maze) &amp;&amp; !audio_is_playing(snd_rewind)
{
    audio_sound_gain(global.music,0,500);
    snd_rew = audio_play_sound(snd_rewind,5,false);
    snd_back_music = audio_play_sound(snd_Eternal_Boredom,5,true);
    audio_sound_gain(snd_back_music,0.5,180);
    audio_sound_gain(snd_rew,0.8,120);
}
else
{
    snd_rew = noone;
    snd_back_music = noone;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///GAME_STATE = GAMEPLAY and other

mp_grid_destroy(mp_maze_grid);

if maze_conditions_passed == false
{
    instance_create(0,0,obj_maze_generator);
    show_debug_message("MAZE FAILED. NEW MAZE.");
    event_user(1); //Clear the generated objects
    exit;
}

mp_maze_grid = mp_grid_create(0,0,maze_size,maze_size,tile_size,tile_size);
mp_grid_add_instances(mp_maze_grid,obj_wall,false);

ds_grid_destroy(maze_grid);
if !instance_exists(obj_player) then instance_create(starting_x*tile_size+tile_size*2,starting_y*tile_size+tile_size,obj_player);
else
{
    obj_player.x = starting_x*tile_size+tile_size*2;
    obj_player.y = starting_y*tile_size+tile_size;
    
    instance_create(starting_x*tile_size+tile_size*2,starting_y*tile_size+tile_size,efct_spawn_beam);
}

game_state = "GAMEPLAY";
camera.follow_this = obj_player;


//Music and rewind sound
if audio_sound_get_gain(global.music) != 1
{
    audio_sound_gain(global.music,1,120);
}

if audio_is_playing(snd_rewind)
{
    audio_sound_gain(snd_rew,0,200);
}

if audio_is_playing(snd_Eternal_Boredom)
{
    audio_stop_sound(snd_back_music);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CARVE THE LABYRINTH!
if game_state == "PAUSE" || game_state == "DEATH" || game_state == "WIN" then exit;

//NOTE: When checking for grid coordinates, an invalid coordinate will also return 0.
if maze_complete == false
{
    //Select a random direction
    var move_to = choose("N","S","W","E");
    
    //Pick a new direction if the current direction is in the list.
    if ds_list_find_index(directions_checked,move_to) != -1
    {
        //If all directions checked, backstep. Otherwise find a new direction.
        if ds_list_size(directions_checked) &gt;= 4
        {
            ds_list_clear(directions_checked);
            
            if ds_list_size(visited_cells_x) &gt; 0
            {
                show_debug_message("MAZE GEN&gt; Entering backstep routine..");
                backstep = true;
                backstep_position = ds_list_size(visited_cells_x)-1;
            }
        }
        else
        {
            while(ds_list_find_index(directions_checked,move_to) != -1)
            {
                move_to = choose("N","S","W","E");
            }
        }
    }
    
    ds_list_add(directions_checked,move_to);
    
    var next_x = carver_x+directions_x[? move_to]*path_length;
    var next_y = carver_y+directions_y[? move_to]*path_length;
    
    if move_to != undefined &amp;&amp; next_x &gt; 0 &amp;&amp; next_y &gt; 0 &amp;&amp; next_x &lt; maze_size-1 &amp;&amp; next_y &lt; maze_size-1 &amp;&amp; ds_grid_get(maze_grid,next_x,next_y) != 0
    {
        maze_grid_update(move_to,path_length);
        backstep = false;
        scr_playSound(snd_generic_selection,false,2,-1,-1,0.5,true);
    }
    
    //BACKSTEP
    if (backstep == true &amp;&amp; ds_list_size(visited_cells_x) &gt; 0)
    {
        ds_list_delete(visited_cells_x,backstep_position);
        ds_list_delete(visited_cells_y,backstep_position);
        backstep_position -= 1;
        carver_x = ds_list_find_value(visited_cells_x,backstep_position);
        carver_y = ds_list_find_value(visited_cells_y,backstep_position);
    
        if backstep_position &lt;= 0
        {
            backstep = false;
            maze_complete = true;
            event_user(0); //MAZE COMPLETED EVENT
            show_debug_message("BACKSTEP REACHED 0. MAZE COMPLETE.");
        }
    }
}
else
{    
    //Zoom into the maze
    camera.zoom = 1;
    camera.zoom_speed = 3;
    //- set zoom targets
    camera.x_zoom = 256/camera.zoom;
    camera.y_zoom = 256/camera.zoom;
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_yview -= 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_yview += 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview += 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview -= 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CLEAR THE MAZE OBJECTS
if instance_exists(obj_wall)
{
    with obj_wall instance_destroy();
}

if instance_exists(obj_road)
{
    with obj_road instance_destroy();
}

if instance_exists(obj_door)
{
    with obj_door instance_destroy();
}

if instance_exists(obj_key)
{
    with obj_key instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///MAZE COMPLETED EVENT
//Here we want to take our maze and make it playable!

//Punch middle hole
hole_size = 3; //A 3x3 hole.
starting_x = floor(maze_size/2);
starting_y = floor(maze_size/2);

//Punch a hole to place the character
for(_i=0;_i&lt;hole_size*hole_size;_i++)
{
    var column = floor(_i/hole_size);
    ds_grid_set(maze_grid,starting_x+_i-(column*hole_size),starting_y+column,0);   
}

//Generate key locations or puzzles
// - Generate exit
var horizontal_exit = choose(true,false);

show_debug_message("Exit on top or bottom: "+string(horizontal_exit));
if horizontal_exit = true
{
    var _y = choose(0,maze_size-1);
    var _x = irandom_range(1,maze_size-2);
    
    ds_grid_set(maze_grid,_x,_y,1);
    instance_create(_x*tile_size,_y*tile_size,obj_door);
    
    //if the exit is at the bottom of the map, build up
    if _y &gt; maze_size/2
    {
        for(_i=1;_i&lt;maze_size;_i++)
        {
            if ds_grid_get(maze_grid,_x,_y-_i) == 0 then break;
            ds_grid_set(maze_grid,_x,_y-_i,0);
        }
    }
    else
    {
        for(_i=1;_i&lt;maze_size;_i++)
        {
            if ds_grid_get(maze_grid,_x,_y+_i) == 0 then break;
            ds_grid_set(maze_grid,_x,_y+_i,0);
        }
    }
}
else
{
    var _y = irandom_range(1,maze_size-2);
    var _x = choose(0,maze_size-1);
    
    ds_grid_set(maze_grid,_x,_y,0);
    instance_create(_x*tile_size,_y*tile_size,obj_door);
    
    //if the exit is at the right of the map, build left
    if _x &gt; maze_size/2
    {
        for(_i=1;_i&lt;maze_size;_i++)
        {
            if ds_grid_get(maze_grid,_x-_i,_y) == 0 then break;
            ds_grid_set(maze_grid,_x-_i,_y,0);
        }
    }
    else
    {
        for(_i=1;_i&lt;maze_size;_i++)
        {
            if ds_grid_get(maze_grid,_x+_i,_y) == 0 then break;
            ds_grid_set(maze_grid,_x+_i,_y,0);
        }
    }
}

//Place keys
var key_amt = 1 + maze_difficulty div 7; //NOTE: Must not exceed potential dead ends! Should be impossible under normal circumstances.
var dead_end_list = ds_list_create();

for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        if ds_grid_get(maze_grid,f,i) == 0
        {
            if maze_check_dead_end(maze_grid,f,i,1)
            {
                var point = array_create(2);
                point[0] = f;
                point[1] = i;
                ds_list_add(dead_end_list,point);
            }
        }
    }
}

//- Pick a random location from our potential locations to spawn a key.
while(key_amt &gt; 0)
{
    var selected_point = ds_list_find_value(dead_end_list,irandom(ds_list_size(dead_end_list)-1));
    instance_create(selected_point[0]*tile_size,selected_point[1]*tile_size,obj_key);
    
    key_amt -= 1;
}

//Convert to objects
for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        var door_pos_check = collision_point(tile_size*f+16,tile_size*i+16,obj_door,false,true);
    
        if ds_grid_get(maze_grid,f,i) == 1 &amp;&amp; door_pos_check == noone
        {
            instance_create(tile_size*f,tile_size*i,obj_wall);
        }
        else if ds_grid_get(maze_grid,f,i) == 0
        { 
            instance_create(tile_size*f,tile_size*i,obj_road);
        }
    }
}

//- update the sprites
with obj_wall
{
    var xx = x+16;
    var yy = y+16;
    
    //If tiles are above us or below us that means we must connect them! okay?
    if collision_point(xx,yy-32,obj_wall,false,true) != noone || collision_point(xx,yy+32,obj_wall,false,true) != noone
    {
        image_index = 1;
    }
    
    if collision_point(xx,yy+32,obj_wall,false,true) == noone
    {
        image_index = 0;
    }
}

//- if more than 65% of the walls remain, regenerate the maze.
var maze_ratio = instance_number(obj_wall)/(maze_size*maze_size);
show_debug_message("Maze Ratio: "+string(maze_ratio));

if maze_ratio &gt; 0.65
{
    instance_destroy();
    exit;
}

//Pass the completed maze_grid to the game.
ds_grid_destroy(current_maze);
current_maze = ds_grid_create(maze_size,maze_size);
ds_grid_copy(current_maze,maze_grid);

//Passed all conditions.
maze_conditions_passed = true;


//Create player
//instance_create(starting_x*tile_size+tile_size*2,starting_y*tile_size+tile_size,obj_player);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the generation process
for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        if ds_grid_get(maze_grid,f,i) == 1
        {
            draw_sprite(spr_tile_small,1,f*tile_size,i*tile_size);
        }
    }
}

draw_sprite(spr_grass,0,carver_x*tile_size,carver_y*tile_size);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
